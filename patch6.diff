diff --git a/src/main/java/com/pilates/booking/service/UserService.java b/src/main/java/com/pilates/booking/service/UserService.java
index ef9384f98bcecbfa5055f2a96d8d6bb57a34e84c..b471548672f05e8fd3afeaa9b1d7f769ce43ab1b 100644
--- a/src/main/java/com/pilates/booking/service/UserService.java
+++ b/src/main/java/com/pilates/booking/service/UserService.java
@@ -1,43 +1,45 @@
 package com.pilates.booking.service;
 
 import com.pilates.booking.config.Constants;
 import com.pilates.booking.domain.Authority;
 import com.pilates.booking.domain.User;
 import com.pilates.booking.repository.AuthorityRepository;
 import com.pilates.booking.repository.UserRepository;
 import com.pilates.booking.security.AuthoritiesConstants;
 import com.pilates.booking.security.SecurityUtils;
 import com.pilates.booking.service.dto.AdminUserDTO;
 import com.pilates.booking.service.dto.UserDTO;
 import java.time.Instant;
 import java.time.LocalDateTime;
 import java.time.ZoneOffset;
 import java.time.temporal.ChronoUnit;
 import java.util.*;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.springframework.dao.DataIntegrityViolationException;
+import org.springframework.dao.DuplicateKeyException;
 import org.springframework.data.domain.Pageable;
 import org.springframework.scheduling.annotation.Scheduled;
 import org.springframework.security.crypto.password.PasswordEncoder;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional;
 import reactor.core.publisher.Flux;
 import reactor.core.publisher.Mono;
 import reactor.core.scheduler.Schedulers;
 import tech.jhipster.security.RandomUtil;
 
 /**
  * Service class for managing users.
  */
 @Service
 public class UserService {
 
     private static final Logger LOG = LoggerFactory.getLogger(UserService.class);
 
     private final UserRepository userRepository;
 
     private final PasswordEncoder passwordEncoder;
 
     private final AuthorityRepository authorityRepository;
 
     public UserService(UserRepository userRepository, PasswordEncoder passwordEncoder, AuthorityRepository authorityRepository) {
@@ -80,140 +82,158 @@ public class UserService {
     public Mono<User> requestPasswordReset(String mail) {
         return userRepository
             .findOneByEmailIgnoreCase(mail)
             .filter(User::isActivated)
             .publishOn(Schedulers.boundedElastic())
             .map(user -> {
                 user.setResetKey(RandomUtil.generateResetKey());
                 user.setResetDate(Instant.now());
                 return user;
             })
             .flatMap(this::saveUser);
     }
 
     @Transactional
     public Mono<User> registerUser(AdminUserDTO userDTO, String password) {
         return userRepository
             .findOneByLogin(userDTO.getLogin().toLowerCase())
             .flatMap(existingUser -> {
                 if (!existingUser.isActivated()) {
                     return userRepository.delete(existingUser);
                 } else {
                     return Mono.error(new UsernameAlreadyUsedException());
                 }
             })
             .then(userRepository.findOneByEmailIgnoreCase(userDTO.getEmail()))
-            .flatMap(existingUser -> {
-                if (!existingUser.isActivated()) {
-                    return userRepository.delete(existingUser);
-                } else {
-                    return Mono.error(new EmailAlreadyUsedException());
-                }
-            })
+            .flatMap(existingUser -> Mono.error(new EmailAlreadyUsedException()))
+            .then(
+                Mono.justOrEmpty(userDTO.getPhone())
+                    .flatMap(userRepository::findOneByPhone)
+                    .flatMap(existingUser -> Mono.error(new PhoneAlreadyUsedException()))
+            )
             .publishOn(Schedulers.boundedElastic())
             .then(
                 Mono.fromCallable(() -> {
                     User newUser = new User();
                     String encryptedPassword = passwordEncoder.encode(password);
                     newUser.setLogin(userDTO.getLogin().toLowerCase());
                     // new user gets initially a generated password
                     newUser.setPassword(encryptedPassword);
                     newUser.setFirstName(userDTO.getFirstName());
                     newUser.setLastName(userDTO.getLastName());
                     if (userDTO.getEmail() != null) {
                         newUser.setEmail(userDTO.getEmail().toLowerCase());
                     }
+                    newUser.setPhone(userDTO.getPhone());
                     newUser.setImageUrl(userDTO.getImageUrl());
                     newUser.setLangKey(userDTO.getLangKey());
                     // new user is active by default in dev/simplified flow
                     newUser.setActivated(true);
                     // new user gets registration key
                     newUser.setActivationKey(RandomUtil.generateActivationKey());
                     return newUser;
                 })
             )
             .flatMap(newUser -> {
                 Set<Authority> authorities = new HashSet<>();
                 return authorityRepository
                     .findById(AuthoritiesConstants.USER)
                     .map(authorities::add)
                     .thenReturn(newUser)
                     .doOnNext(user -> user.setAuthorities(authorities))
                     .flatMap(this::saveUser)
                     .doOnNext(user -> LOG.debug("Created Information for User: {}", user));
-            });
+            })
+            .onErrorMap(this::mapDuplicateUserConstraint);
+    }
+
+    private Throwable mapDuplicateUserConstraint(Throwable throwable) {
+        if (!(throwable instanceof DuplicateKeyException) && !(throwable instanceof DataIntegrityViolationException)) {
+            return throwable;
+        }
+
+        String message = throwable.getMessage();
+        if (message != null && (message.contains("ux_user_phone") || message.contains("ux_jhi_user__phone"))) {
+            return new PhoneAlreadyUsedException();
+        }
+        if (message != null && (message.contains("ux_user_email") || message.contains("ux_jhi_user__email"))) {
+            return new EmailAlreadyUsedException();
+        }
+        return throwable;
     }
 
     @Transactional
     public Mono<User> createUser(AdminUserDTO userDTO) {
         User user = new User();
         user.setLogin(userDTO.getLogin().toLowerCase());
         user.setFirstName(userDTO.getFirstName());
         user.setLastName(userDTO.getLastName());
         if (userDTO.getEmail() != null) {
             user.setEmail(userDTO.getEmail().toLowerCase());
         }
+        user.setPhone(userDTO.getPhone());
         user.setImageUrl(userDTO.getImageUrl());
         if (userDTO.getLangKey() == null) {
             user.setLangKey(Constants.DEFAULT_LANGUAGE); // default language
         } else {
             user.setLangKey(userDTO.getLangKey());
         }
         return Flux.fromIterable(userDTO.getAuthorities() != null ? userDTO.getAuthorities() : new HashSet<>())
             .flatMap(authorityRepository::findById)
             .doOnNext(authority -> user.getAuthorities().add(authority))
             .then(Mono.just(user))
             .publishOn(Schedulers.boundedElastic())
             .map(newUser -> {
                 String encryptedPassword = passwordEncoder.encode(RandomUtil.generatePassword());
                 newUser.setPassword(encryptedPassword);
                 newUser.setResetKey(RandomUtil.generateResetKey());
                 newUser.setResetDate(Instant.now());
                 newUser.setActivated(true);
                 return newUser;
             })
             .flatMap(this::saveUser)
             .doOnNext(user1 -> LOG.debug("Created Information for User: {}", user1));
     }
 
     /**
      * Update all information for a specific user, and return the modified user.
      *
      * @param userDTO user to update.
      * @return updated user.
      */
     @Transactional
     public Mono<AdminUserDTO> updateUser(AdminUserDTO userDTO) {
         return userRepository
             .findById(userDTO.getId())
             .flatMap(user -> {
                 user.setLogin(userDTO.getLogin().toLowerCase());
                 user.setFirstName(userDTO.getFirstName());
                 user.setLastName(userDTO.getLastName());
                 if (userDTO.getEmail() != null) {
                     user.setEmail(userDTO.getEmail().toLowerCase());
                 }
+                user.setPhone(userDTO.getPhone());
                 user.setImageUrl(userDTO.getImageUrl());
                 user.setActivated(userDTO.isActivated());
                 user.setLangKey(userDTO.getLangKey());
                 Set<Authority> managedAuthorities = user.getAuthorities();
                 managedAuthorities.clear();
                 return userRepository
                     .deleteUserAuthorities(user.getId())
                     .thenMany(Flux.fromIterable(userDTO.getAuthorities()))
                     .flatMap(authorityRepository::findById)
                     .map(managedAuthorities::add)
                     .then(Mono.just(user));
             })
             .flatMap(this::saveUser)
             .doOnNext(user -> LOG.debug("Changed Information for User: {}", user))
             .map(AdminUserDTO::new);
     }
 
     @Transactional
     public Mono<Void> deleteUser(String login) {
         return userRepository
             .findOneByLogin(login)
             .flatMap(user -> userRepository.delete(user).thenReturn(user))
             .doOnNext(user -> LOG.debug("Deleted User: {}", user))
             .then();
     }
